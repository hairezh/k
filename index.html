<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>osu!mania Key/Note Image Generator</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#121a29;
      --panel2:#0f1624;
      --text:#e7eefc;
      --muted:#a9b7d6;
      --acc:#7aa7ff;
      --ok:#2fe29a;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --border: rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 10%, rgba(122,167,255,.18), transparent 60%),
                  radial-gradient(900px 700px at 80% 20%, rgba(47,226,154,.10), transparent 55%),
                  var(--bg);
    }
    header{
      padding: 22px 18px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }
    h1{
      margin:0;
      font-size: 20px;
      letter-spacing:.2px;
    }
    header p{
      margin:8px 0 0;
      color:var(--muted);
      line-height:1.35;
      max-width: 90ch;
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px 18px 28px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap: 14px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 14px 10px;
      background: rgba(0,0,0,.12);
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .card .hd b{font-size: 13px; letter-spacing:.2px}
    .card .bd{padding: 14px}
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
    }
    input, select{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    input[type="color"]{
      padding: 5px;
      height: 38px;
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .btn{
      cursor:pointer;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(122,167,255,.22), rgba(122,167,255,.08));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 650;
      letter-spacing:.2px;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    .btn.secondary{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      font-weight: 600;
    }
    .btn.ok{
      background: linear-gradient(180deg, rgba(47,226,154,.22), rgba(47,226,154,.08));
    }
    .btn.warn{
      background: linear-gradient(180deg, rgba(255,204,102,.22), rgba(255,204,102,.08));
    }
    .pill{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      padding: 6px 10px;
      border-radius: 999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .mono{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      line-height:1.35;
    }
    .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .preview{
      padding: 14px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .canvasWrap{
      background: rgba(0,0,0,.22);
      border:1px solid var(--border);
      border-radius: var(--r);
      padding: 12px;
      overflow:auto;
    }
    canvas{
      background: #070a10;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.06);
      display:block;
      margin: 0 auto;
    }
    .out{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
      gap: 10px;
    }
    .thumb{
      border:1px solid var(--border);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    .thumb .toph{
      padding: 10px 10px 8px;
      border-bottom: 1px solid var(--border);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .thumb b{
      font-size: 12px;
      font-family: var(--mono);
    }
    .thumb .img{
      padding: 10px;
      display:grid;
      gap:10px;
      justify-items:center;
    }
    .thumb img{
      max-width: 100%;
      image-rendering: auto;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.06);
      background: rgba(255,255,255,.02);
    }
    .smallRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .footerNote{
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      line-height:1.35;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
<header>
  <h1>Gerador nerd de imagens (osu!mania): Keys + Notes</h1>
  <p>
    Ajuste HitPosition, tamanhos e estilo. O gerador cria PNGs base + downscale automaticamente.
    Incluí também o cálculo pra alinhar a imagem no HitPosition (âncora no <span class="pill">bottom</span> ou no <span class="pill">center</span>).
  </p>
</header>

<div class="wrap">

  <section class="card">
    <div class="hd">
      <b>Configurações</b>
      <span class="pill" id="statusPill">pronto</span>
    </div>
    <div class="bd">
      <div class="grid">
        <label>
          ScreenHeight (base do osu)
          <input id="screenH" type="number" value="480" min="100" step="1">
        </label>
        <label>
          HitPosition (Y do hitline)
          <input id="hitPos" type="number" value="458" min="0" step="1">
        </label>

        <label>
          Alinhamento da KEY no HitPosition
          <select id="anchorMode">
            <option value="bottom">bottom (mais comum pra receptor)</option>
            <option value="center">center (linha no meio da imagem)</option>
          </select>
        </label>

        <label>
          Número de teclas (k)
          <input id="keyCount" type="number" value="4" min="1" max="18" step="1">
        </label>
      </div>

      <div class="split">
        <div class="card" style="box-shadow:none;border-radius:14px;">
          <div class="hd"><b>Keys</b><span class="pill">base 224×366 → 112×183</span></div>
          <div class="bd">
            <div class="grid">
              <label>Key Base W <input id="keyW" type="number" value="224" min="8" step="1"></label>
              <label>Key Base H <input id="keyH" type="number" value="366" min="8" step="1"></label>
              <label>Cor principal <input id="keyColor" type="color" value="#7aa7ff"></label>
              <label>Cor borda <input id="keyBorder" type="color" value="#0a1020"></label>
              <label>Raio (cantos) <input id="keyRadius" type="number" value="26" min="0" step="1"></label>
              <label>Brilho topo (0-1) <input id="keyShine" type="number" value="0.35" min="0" max="1" step="0.01"></label>
            </div>
          </div>
        </div>

        <div class="card" style="box-shadow:none;border-radius:14px;">
          <div class="hd"><b>Notes</b><span class="pill">base 300×300 → 150×150</span></div>
          <div class="bd">
            <div class="grid">
              <label>Note Base W <input id="noteW" type="number" value="300" min="8" step="1"></label>
              <label>Note Base H <input id="noteH" type="number" value="300" min="8" step="1"></label>
              <label>Cor principal <input id="noteColor" type="color" value="#2fe29a"></label>
              <label>Cor borda <input id="noteBorder" type="color" value="#0a1020"></label>
              <label>Raio (cantos) <input id="noteRadius" type="number" value="42" min="0" step="1"></label>
              <label>Brilho topo (0-1) <input id="noteShine" type="number" value="0.30" min="0" max="1" step="0.01"></label>
            </div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button class="btn ok" id="genBtn">Gerar tudo</button>
        <button class="btn secondary" id="clearBtn">Limpar saída</button>
        <button class="btn warn" id="zipBtn">Baixar ZIP</button>
      </div>

      <div class="footerNote mono" id="calcBox" style="margin-top:12px;"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <b>Preview + Saída</b>
      <span class="pill">sem dependências pesadas</span>
    </div>

    <div class="preview">
      <div class="canvasWrap">
        <canvas id="preview" width="520" height="520"></canvas>
        <div class="footerNote mono" id="previewLegend"></div>
      </div>

      <div class="out" id="out"></div>
    </div>
  </section>

</div>

<!-- JSZip via CDN (para zip). Se você quiser 100% offline, eu te adapto pra baixar individualmente sem ZIP. -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
/* ----------------------------- helpers ----------------------------- */
const $ = (id) => document.getElementById(id);

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function hexToRgba(hex, a=1){
  const h = hex.replace("#","");
  const r = parseInt(h.slice(0,2), 16);
  const g = parseInt(h.slice(2,4), 16);
  const b = parseInt(h.slice(4,6), 16);
  return `rgba(${r},${g},${b},${a})`;
}

function roundRectPath(ctx, x, y, w, h, r){
  r = clamp(r, 0, Math.min(w,h)/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function setStatus(text){
  $("statusPill").textContent = text;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1200);
}

async function canvasToBlob(canvas){
  return await new Promise((res)=>canvas.toBlob(res, "image/png"));
}

function makeCanvas(w,h){
  const c = document.createElement("canvas");
  c.width = Math.max(1, Math.floor(w));
  c.height = Math.max(1, Math.floor(h));
  return c;
}

function downscaleCanvas(srcCanvas, targetW, targetH){
  const dst = makeCanvas(targetW, targetH);
  const dctx = dst.getContext("2d");
  dctx.imageSmoothingEnabled = true;
  dctx.imageSmoothingQuality = "high";
  dctx.clearRect(0,0,dst.width,dst.height);
  dctx.drawImage(srcCanvas, 0,0, dst.width, dst.height);
  return dst;
}

/* ------------------------- draw styles ---------------------------- */
function drawFancyTile(ctx, w, h, opts){
  const {
    fill="#7aa7ff",
    border="#0a1020",
    radius=24,
    shine=0.35,
    label=""
  } = opts;

  ctx.clearRect(0,0,w,h);

  // background (subtle)
  const bg = ctx.createLinearGradient(0,0,0,h);
  bg.addColorStop(0, "rgba(255,255,255,0.03)");
  bg.addColorStop(1, "rgba(0,0,0,0.15)");
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,w,h);

  // main shape
  const pad = Math.max(2, Math.round(Math.min(w,h)*0.06));
  const x = pad, y = pad, ww = w-pad*2, hh = h-pad*2;

  // base gradient
  const g = ctx.createLinearGradient(0, y, 0, y+hh);
  g.addColorStop(0, hexToRgba(fill, 0.95));
  g.addColorStop(1, hexToRgba(fill, 0.55));
  ctx.fillStyle = g;

  roundRectPath(ctx, x, y, ww, hh, radius);
  ctx.fill();

  // shine top
  const sh = ctx.createLinearGradient(0, y, 0, y+hh*0.6);
  sh.addColorStop(0, "rgba(255,255,255," + shine + ")");
  sh.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = sh;
  roundRectPath(ctx, x, y, ww, hh, radius);
  ctx.fill();

  // inner line
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.012));
  roundRectPath(ctx, x+ctx.lineWidth, y+ctx.lineWidth, ww-ctx.lineWidth*2, hh-ctx.lineWidth*2, Math.max(0, radius-ctx.lineWidth));
  ctx.stroke();

  // border
  ctx.strokeStyle = hexToRgba(border, 0.95);
  ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.018));
  roundRectPath(ctx, x, y, ww, hh, radius);
  ctx.stroke();

  // label (debug-ish)
  if(label){
    ctx.font = `700 ${Math.max(12, Math.round(Math.min(w,h)*0.12))}px ${getComputedStyle(document.body).fontFamily}`;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, w/2, h/2);
  }
}

/* ------------------------- generation ----------------------------- */
function getConfig(){
  const screenH = Number($("screenH").value);
  const hitPos = Number($("hitPos").value);
  const anchorMode = $("anchorMode").value;
  const keyCount = clamp(Number($("keyCount").value), 1, 18);

  const keyW = Number($("keyW").value);
  const keyH = Number($("keyH").value);
  const noteW = Number($("noteW").value);
  const noteH = Number($("noteH").value);

  return {
    screenH, hitPos, anchorMode, keyCount,
    key: {
      w:keyW, h:keyH,
      color:$("keyColor").value,
      border:$("keyBorder").value,
      radius:Number($("keyRadius").value),
      shine:Number($("keyShine").value),
      baseDownscale: { w: Math.round(keyW/2), h: Math.round(keyH/2) }
    },
    note: {
      w:noteW, h:noteH,
      color:$("noteColor").value,
      border:$("noteBorder").value,
      radius:Number($("noteRadius").value),
      shine:Number($("noteShine").value),
      baseDownscale: { w: Math.round(noteW/2), h: Math.round(noteH/2) }
    }
  };
}

function updateCalcUI(){
  const cfg = getConfig();
  const H = cfg.screenH;
  const y = cfg.hitPos;

  const keyH = cfg.key.h;

  // where the top of the key image would land in screen coords (for preview)
  const topBottomAnchor = y - keyH;
  const topCenterAnchor = y - keyH/2;

  const maxCenterFit = 2 * Math.min(y, H - y);
  const maxBottomFit = y; // if anchored by bottom, it fits if keyH <= hitPos (top >= 0)

  const lines = [];
  lines.push(`<span class="pill">Cálculos</span>`);
  lines.push(`<div class="mono" style="margin-top:8px">`);
  lines.push(`• <b>Bottom-anchor</b>: <span class="pill">top = hitPos - keyH</span> ⇒ top = ${y} - ${keyH} = <b>${Math.round(topBottomAnchor)}</b> px`);
  lines.push(`<br>• <b>Center-anchor</b>: <span class="pill">top = hitPos - keyH/2</span> ⇒ top = ${y} - ${keyH/2} = <b>${Math.round(topCenterAnchor)}</b> px`);
  lines.push(`<br><br>Pra escolher um <b>keyH</b> que “caiba” sem cortar:`);
  lines.push(`<br>• Se for <b>center-anchor</b>: <span class="pill">keyH ≤ 2 * min(hitPos, screenH - hitPos)</span> ⇒ máximo ≈ <b>${Math.floor(maxCenterFit)}</b> px`);
  lines.push(`<br>• Se for <b>bottom-anchor</b>: <span class="pill">keyH ≤ hitPos</span> ⇒ máximo ≈ <b>${Math.floor(maxBottomFit)}</b> px`);
  lines.push(`</div>`);

  $("calcBox").innerHTML = lines.join("");
}

function drawPreview(){
  const cfg = getConfig();
  const canvas = $("preview");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // coordinate map: we display a "screen" area of height cfg.screenH inside preview
  const pad = 28;
  const viewW = canvas.width - pad*2;
  const viewH = canvas.height - pad*2;

  // draw playfield box
  ctx.fillStyle = "rgba(255,255,255,0.03)";
  ctx.fillRect(pad, pad, viewW, viewH);
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.strokeRect(pad, pad, viewW, viewH);

  // map y (0..screenH) to preview
  const H = cfg.screenH;
  const yHit = cfg.hitPos;
  const mapY = (y) => pad + (y / H) * viewH;

  // hit line
  const yh = mapY(yHit);
  ctx.strokeStyle = "rgba(255,204,102,0.85)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(pad, yh);
  ctx.lineTo(pad+viewW, yh);
  ctx.stroke();

  // key rect position with chosen anchor
  const keyH = cfg.key.h;
  const keyW = cfg.key.w;
  const anchor = cfg.anchorMode;

  let topScreen;
  if(anchor === "bottom") topScreen = yHit - keyH;
  else topScreen = yHit - keyH/2;

  const keyTopY = mapY(topScreen);
  const keyBottomY = mapY(topScreen + keyH);

  // scale key box width relative
  const boxW = clamp((keyW / 224) * 120, 60, 220);
  const boxX = pad + (viewW - boxW)/2;

  // draw key box
  ctx.fillStyle = "rgba(122,167,255,0.18)";
  ctx.fillRect(boxX, keyTopY, boxW, keyBottomY - keyTopY);
  ctx.strokeStyle = "rgba(122,167,255,0.75)";
  ctx.lineWidth = 2;
  ctx.strokeRect(boxX, keyTopY, boxW, keyBottomY - keyTopY);

  // text
  ctx.fillStyle = "rgba(231,238,252,0.85)";
  ctx.font = `600 12px ${getComputedStyle(document.body).fontFamily}`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(`screenH=${H}px | hitPos=${yHit}px | anchor=${anchor}`, pad, 8);

  $("previewLegend").textContent =
    `Linha amarela = HitPosition. Retângulo azul = onde a KEY cairia na tela com o anchor escolhido (sem “mágica”, só matemática).`;
}

function addThumbBlock(title, images){
  const out = $("out");
  const wrap = document.createElement("div");
  wrap.className = "thumb";

  const top = document.createElement("div");
  top.className = "toph";

  const b = document.createElement("b");
  b.textContent = title;

  const btnRow = document.createElement("div");
  btnRow.className = "row";

  top.appendChild(b);
  top.appendChild(btnRow);

  const imgBox = document.createElement("div");
  imgBox.className = "img";

  const smallRow = document.createElement("div");
  smallRow.className = "smallRow";

  images.forEach(({name, url, blob})=>{
    const img = document.createElement("img");
    img.src = url;
    img.alt = name;
    imgBox.appendChild(img);

    const dl = document.createElement("button");
    dl.className = "btn secondary";
    dl.style.padding = "7px 10px";
    dl.style.borderRadius = "12px";
    dl.textContent = "baixar " + name;
    dl.onclick = ()=> downloadBlob(blob, name);
    smallRow.appendChild(dl);
  });

  imgBox.appendChild(smallRow);

  wrap.appendChild(top);
  wrap.appendChild(imgBox);
  out.appendChild(wrap);
}

let generatedFiles = []; // {name, blob}

/* ----------------------------- main gen --------------------------- */
async function generateAll(){
  setStatus("gerando…");
  $("out").innerHTML = "";
  generatedFiles = [];

  const cfg = getConfig();

  // Generate Keys (k variants)
  for(let i=1;i<=cfg.keyCount;i++){
    const c = makeCanvas(cfg.key.w, cfg.key.h);
    const ctx = c.getContext("2d");
    drawFancyTile(ctx, c.width, c.height, {
      fill: cfg.key.color,
      border: cfg.key.border,
      radius: cfg.key.radius,
      shine: cfg.key.shine,
      label: String(i)
    });

    const down = downscaleCanvas(c, cfg.key.baseDownscale.w, cfg.key.baseDownscale.h);

    const blobBase = await canvasToBlob(c);
    const blobDown = await canvasToBlob(down);

    const nameBase = `mania-key${i}.png`;
    const nameDown = `mania-key${i}@2xdown.png`; // nome livre (você pode renomear depois)

    generatedFiles.push({name:nameBase, blob:blobBase});
    generatedFiles.push({name:nameDown, blob:blobDown});

    const urlBase = URL.createObjectURL(blobBase);
    const urlDown = URL.createObjectURL(blobDown);

    addThumbBlock(`Key ${i}`, [
      {name: nameBase, url:urlBase, blob: blobBase},
      {name: nameDown, url:urlDown, blob: blobDown},
    ]);
  }

  // Generate Notes (k variants)
  for(let i=1;i<=cfg.keyCount;i++){
    const c = makeCanvas(cfg.note.w, cfg.note.h);
    const ctx = c.getContext("2d");

    // Slightly vary color by column (tiny shift) while still using base color:
    // We'll draw same tile but add a subtle overlay.
    drawFancyTile(ctx, c.width, c.height, {
      fill: cfg.note.color,
      border: cfg.note.border,
      radius: cfg.note.radius,
      shine: cfg.note.shine,
      label: ""
    });

    // overlay “gem” stripe so notes look different from keys
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.beginPath();
    ctx.moveTo(0, c.height*0.25);
    ctx.lineTo(c.width, c.height*0.05);
    ctx.lineTo(c.width, c.height*0.15);
    ctx.lineTo(0, c.height*0.35);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // center mark
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "rgba(0,0,0,1)";
    ctx.lineWidth = Math.max(2, Math.round(Math.min(c.width,c.height)*0.035));
    ctx.beginPath();
    ctx.arc(c.width/2, c.height/2, Math.min(c.width,c.height)*0.18, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    const down = downscaleCanvas(c, cfg.note.baseDownscale.w, cfg.note.baseDownscale.h);

    const blobBase = await canvasToBlob(c);
    const blobDown = await canvasToBlob(down);

    const nameBase = `mania-note${i}.png`;
    const nameDown = `mania-note${i}@2xdown.png`;

    generatedFiles.push({name:nameBase, blob:blobBase});
    generatedFiles.push({name:nameDown, blob:blobDown});

    const urlBase = URL.createObjectURL(blobBase);
    const urlDown = URL.createObjectURL(blobDown);

    addThumbBlock(`Note ${i}`, [
      {name: nameBase, url:urlBase, blob: blobBase},
      {name: nameDown, url:urlDown, blob: blobDown},
    ]);
  }

  setStatus("pronto ✅");
}

async function downloadZip(){
  if(!generatedFiles.length){
    setStatus("nada pra zipar");
    return;
  }
  setStatus("zipando…");

  if(typeof JSZip === "undefined"){
    alert("JSZip não carregou. Se você quer 100% offline, eu adapto o site pra baixar tudo individual sem ZIP.");
    setStatus("sem JSZip");
    return;
  }

  const zip = new JSZip();
  const folder = zip.folder("osu-mania-images");
  for(const f of generatedFiles){
    folder.file(f.name, f.blob);
  }
  const blob = await zip.generateAsync({type:"blob"});
  downloadBlob(blob, "osu-mania-images.zip");
  setStatus("pronto ✅");
}

/* --------------------------- wiring ------------------------------- */
function bind(){
  const ids = ["screenH","hitPos","anchorMode","keyCount","keyW","keyH","noteW","noteH","keyColor","keyBorder","keyRadius","keyShine","noteColor","noteBorder","noteRadius","noteShine"];
  ids.forEach(id=>{
    $(id).addEventListener("input", ()=>{
      updateCalcUI();
      drawPreview();
    });
  });

  $("genBtn").addEventListener("click", generateAll);
  $("clearBtn").addEventListener("click", ()=>{
    $("out").innerHTML = "";
    generatedFiles = [];
    setStatus("limpo");
  });
  $("zipBtn").addEventListener("click", downloadZip);

  updateCalcUI();
  drawPreview();
}
bind();
</script>
</body>
</html>
