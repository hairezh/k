<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>osu!mania Circle Generator</title>

  <style>
    :root{
      --text:#eef2ff;
      --muted:rgba(238,242,255,.72);
      --panel:rgba(10,12,16,.42);
      --border:rgba(255,255,255,.10);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --r:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background-image:
        linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.70)),
        url("https://backiee.com/static/wallpapers/1000x563/414483.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-attachment: fixed;
    }

    .wrap{
      max-width: 1120px;
      margin: 0 auto;
      padding: 28px 18px 40px;
      display:grid;
      grid-template-columns: 380px 1fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      border:1px solid var(--border);
      border-radius: var(--r);
      background: var(--panel);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    header.card{
      grid-column: 1 / -1;
      padding: 16px 16px 14px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
    }

    h1{ margin:0; font-size: 16px; letter-spacing:.2px; font-weight: 750; }
    .sub{ margin: 6px 0 0; color: var(--muted); font-size: 12px; line-height:1.35; }

    .pill{
      font-family: var(--mono);
      font-size: 11px;
      padding: 6px 10px;
      border:1px solid var(--border);
      border-radius: 999px;
      color: var(--muted);
      background: rgba(0,0,0,.18);
      white-space:nowrap;
    }

    .bd{padding: 14px}
    .sectionTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin: 2px 0 10px;
      color: rgba(255,255,255,.92);
      font-size: 12px; letter-spacing:.18px; font-weight: 750;
    }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid1{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    label{
      display:flex; flex-direction:column; gap:6px;
      font-size: 11px; color: var(--muted);
    }

    input, select{
      width:100%;
      padding: 9px 10px;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
    }

    input[type="color"]{ padding: 5px; height: 38px; }
    input[type="checkbox"]{ width:auto; transform: translateY(1px); accent-color: white; }

    details{
      border:1px solid var(--border);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(0,0,0,.14);
    }
    details summary{
      cursor:pointer;
      padding: 10px 12px;
      list-style:none;
      font-size: 12px;
      font-weight: 700;
      color: rgba(255,255,255,.90);
      user-select:none;
    }
    details summary::-webkit-details-marker{display:none}
    details .inner{padding: 12px; border-top:1px solid var(--border)}
    .help{ color: var(--muted); font-size: 11px; line-height:1.35; margin-top: 6px; }

    .btn{
      cursor:pointer;
      border:1px solid var(--border);
      background: rgba(255,255,255,.10);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 750;
      letter-spacing:.2px;
      user-select:none;
    }
    .btn.primary{ background: rgba(255,255,255,.16); }
    .btn:active{transform: translateY(1px)}

    /* Right side */
    .rightCol{
      display:grid;
      grid-template-rows: auto 1fr;
      gap: 14px;
      padding: 14px;
    }

    .previews{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 980px){
      .previews{grid-template-columns: repeat(2, minmax(0, 1fr));}
    }

    .pv{
      border:1px solid var(--border);
      border-radius: 16px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
      display:grid;
      grid-template-rows: auto 1fr;
      min-height: 170px;
    }
    .pvTop{
      padding: 10px 10px 8px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .pvTop b{ font-family: var(--mono); font-size: 12px; font-weight: 850; letter-spacing: .2px; }
    .pvTop span{ font-family: var(--mono); font-size: 11px; color: var(--muted); }
    .pvBody{
      padding: 10px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .pvBody canvas{
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
    }

    .out{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
      gap: 10px;
    }
    .thumb{
      border:1px solid var(--border);
      border-radius: 16px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    .thumb .top{
      padding: 10px 10px 8px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .thumb b{ font-family: var(--mono); font-size: 12px; font-weight: 800; }
    .thumb .img{ padding: 10px; display:grid; gap:10px; justify-items:center; }
    .thumb img{
      max-width:100%;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
    }
    .smallRow{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }

    .statusLine{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 14px;
      border-top:1px solid var(--border);
      color: var(--muted);
      font-size: 11px;
      font-family: var(--mono);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header class="card">
      <div>
        <h1>osu!mania • keys + notes (círculos)</h1>
        <div class="sub">
          4 previews em tempo real (note → LN → key → pressed). Export automático (sem botão “gerar”).
          Keys @2x fixas em 224×366, centralizadas. Fundo/PNG sempre transparente.
        </div>
      </div>
      <div class="pill" id="statusPill">pronto</div>
    </header>

    <!-- Controls -->
    <section class="card">
      <div class="bd">

        <div class="sectionTitle">
          <div>Geral</div>
          <div class="pill">auto-export</div>
        </div>

        <div class="grid1">
          <label>
            ColumnWidth (lista, por coluna)
            <input id="colWidths" value="70,70,70,70" />
            <div class="help">O tamanho do círculo usa o primeiro ColumnWidth como base.</div>
          </label>

          <div class="grid">
            <label>
              Fator (Keys)
              <input id="keyFactor" type="number" value="1.60" min="0.10" max="4" step="0.01" />
            </label>
            <label>
              Fator (Notes)
              <input id="noteFactor" type="number" value="1.20" min="0.10" max="4" step="0.01" />
            </label>
          </div>

          <details>
            <summary>Export</summary>
            <div class="inner grid1">
              <div class="grid">
                <label>
                  Downscale (%)
                  <input id="downPct" type="number" value="50" min="1" max="99" step="1" />
                </label>
                <label>
                  Notes canvas (@2x) W×H
                  <input id="noteCanvas" value="300x300" />
                </label>
              </div>
              <div class="help">Keys @2x são sempre 224×366. Notes você define (ex.: 300x300). Tudo começa “vazio” (transparente).</div>
            </div>
          </details>
        </div>

        <div style="height:14px"></div>

        <div class="sectionTitle">
          <div>Notas</div>
          <div class="pill">normal + LN</div>
        </div>

        <div class="grid1">
          <div class="grid">
            <label>
              Prefixo (nota normal) (ex.: 1,2,S)
              <input id="notePrefix" value="mania-note" />
            </label>
            <label>
              Prefixo (nota LN) (ex.: 1H,2H,SH)
              <input id="noteLnPrefix" value="mania-noteH" />
            </label>
          </div>

          <div class="grid">
            <label>
              Fill cor
              <input id="noteFillColor" type="color" value="#9a9a9a" />
            </label>
            <label>
              Fill opacidade (0-1)
              <input id="noteFillA" type="number" value="0" min="0" max="1" step="0.01" />
            </label>
          </div>

          <div class="grid">
            <label>
              Outline cor
              <input id="noteOutlineColor" type="color" value="#ffffff" />
            </label>
            <label>
              Outline px (@2x)
              <input id="noteOutlinePx" type="number" value="0" min="0" max="200" step="1" />
            </label>
          </div>

          <div class="grid">
            <label>
              Outline opacidade (0-1)
              <input id="noteOutlineA" type="number" value="0" min="0" max="1" step="0.01" />
            </label>
            <label>
              Offset Y (px)
              <input id="noteYOffset" type="number" value="0" min="-999" max="999" step="1" />
            </label>
          </div>

          <details>
            <summary>LN efeito: “motion blur” (como no seu exemplo)</summary>
            <div class="inner grid1">
              <div class="grid">
                <label>
                  Ativar motion blur
                  <select id="mbOn">
                    <option value="off" selected>não</option>
                    <option value="on">sim</option>
                  </select>
                </label>
                <label>
                  Direção (graus) (90 = pra cima)
                  <input id="mbAngle" type="number" value="90" min="0" max="360" step="1" />
                </label>
              </div>

              <div class="grid">
                <label>
                  Distância (px)
                  <input id="mbDist" type="number" value="35" min="0" max="600" step="1" />
                </label>
                <label>
                  Blur (px)
                  <input id="mbBlur" type="number" value="18" min="0" max="200" step="1" />
                </label>
              </div>

              <div class="grid">
                <label>
                  Força (0-1)
                  <input id="mbAlpha" type="number" value="0" min="0" max="1" step="0.01" />
                </label>
                <label>
                  Passos (qualidade)
                  <input id="mbSteps" type="number" value="22" min="2" max="120" step="1" />
                </label>
              </div>

              <div class="help">
                Esse blur é desenhado atrás da nota LN. Se “Força” = 0, fica invisível (padrão).
              </div>
            </div>
          </details>
        </div>

        <div style="height:14px"></div>

        <div class="sectionTitle">
          <div>Keys</div>
          <div class="pill">224×366 (@2x)</div>
        </div>

        <div class="grid1">
          <div class="grid">
            <label>
              Prefixo (normal)
              <input id="keyPrefix" value="mania-key" />
            </label>
            <label>
              Prefixo (pressed)
              <input id="keyPressedPrefix" value="mania-keyD" />
            </label>
          </div>

          <div class="grid">
            <label>
              Fill cor
              <input id="keyFillColor" type="color" value="#7f7f7f" />
            </label>
            <label>
              Fill opacidade (0-1)
              <input id="keyFillA" type="number" value="0" min="0" max="1" step="0.01" />
            </label>
          </div>

          <div class="grid">
            <label>
              Outline cor
              <input id="keyOutlineColor" type="color" value="#ffffff" />
            </label>
            <label>
              Outline px (@2x)
              <input id="keyOutlinePx" type="number" value="0" min="0" max="200" step="1" />
            </label>
          </div>

          <div class="grid">
            <label>
              Outline opacidade (0-1)
              <input id="keyOutlineA" type="number" value="0" min="0" max="1" step="0.01" />
            </label>
            <label>
              Pressed: darken fill (-1..1)
              <input id="keyPressedDelta" type="number" value="0" min="-1" max="1" step="0.01" />
            </label>
          </div>

          <details>
            <summary>Pressed (override opcional)</summary>
            <div class="inner grid1">
              <div class="grid">
                <label>
                  Pressed fill opacidade (0-1)
                  <input id="keyPressedFillA" type="number" value="" placeholder="(vazio = igual)" />
                </label>
                <label>
                  Pressed outline opacidade (0-1)
                  <input id="keyPressedOutlineA" type="number" value="" placeholder="(vazio = igual)" />
                </label>
              </div>
              <div class="help">Se deixar vazio, herda do normal (com o darken aplicado na cor do fill).</div>
            </div>
          </details>

          <div class="row" style="margin-top:10px;">
            <button class="btn primary" id="zipBtn">Baixar ZIP</button>
            <button class="btn" id="clearBtn">Reset pra transparente</button>
          </div>
        </div>

      </div>

      <div class="statusLine">
        <span>Auto: previews + arquivos</span>
        <span id="fileCount">0 arquivos</span>
      </div>
    </section>

    <!-- Right -->
    <section class="card">
      <div class="rightCol">
        <!-- 4 realtime previews side-by-side -->
        <div class="previews">
          <div class="pv">
            <div class="pvTop"><b>note</b><span id="pvInfoNote">—</span></div>
            <div class="pvBody"><canvas id="pvNote" width="220" height="220"></canvas></div>
          </div>
          <div class="pv">
            <div class="pvTop"><b>note LN</b><span id="pvInfoLn">—</span></div>
            <div class="pvBody"><canvas id="pvLn" width="220" height="220"></canvas></div>
          </div>
          <div class="pv">
            <div class="pvTop"><b>key</b><span id="pvInfoKey">—</span></div>
            <div class="pvBody"><canvas id="pvKey" width="220" height="220"></canvas></div>
          </div>
          <div class="pv">
            <div class="pvTop"><b>key pressed</b><span id="pvInfoKeyP">—</span></div>
            <div class="pvBody"><canvas id="pvKeyP" width="220" height="220"></canvas></div>
          </div>
        </div>

        <!-- downloads -->
        <div class="out" id="out"></div>
      </div>
    </section>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);
    function setStatus(txt){ $("statusPill").textContent = txt; }
    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1200);
    }

    function makeCanvas(w,h){
      const c = document.createElement("canvas");
      c.width = Math.max(1, Math.floor(w));
      c.height = Math.max(1, Math.floor(h));
      return c;
    }

    async function canvasToBlob(canvas){
      return await new Promise(res => canvas.toBlob(res, "image/png"));
    }

    function downscaleCanvas(srcCanvas, pct){
      const t = clamp(pct, 1, 99) / 100;
      const w = Math.max(1, Math.floor(srcCanvas.width * t));
      const h = Math.max(1, Math.floor(srcCanvas.height * t));
      const dst = makeCanvas(w, h);
      const ctx = dst.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(srcCanvas, 0, 0, w, h);
      return dst;
    }

    function parseColWidths(str){
      const parts = str.split(",").map(s=>s.trim()).filter(Boolean);
      const nums = parts.map(p=>Number(p)).filter(n=>Number.isFinite(n) && n>0);
      return nums.length ? nums : [70,70,70,70];
    }

    function parseWxH(str, fallbackW, fallbackH){
      const m = String(str||"").toLowerCase().replace(/\s+/g,"").match(/^(\d+)x(\d+)$/);
      if(!m) return {w:fallbackW, h:fallbackH};
      const w = Math.max(16, Math.min(4096, parseInt(m[1],10)));
      const h = Math.max(16, Math.min(4096, parseInt(m[2],10)));
      return {w,h};
    }

    function hexToRgb(hex){
      const h = hex.replace("#","");
      return {
        r: parseInt(h.slice(0,2),16),
        g: parseInt(h.slice(2,4),16),
        b: parseInt(h.slice(4,6),16),
      };
    }
    function rgbToHex(r,g,b){
      const to = (x)=>x.toString(16).padStart(2,"0");
      return "#" + to(r) + to(g) + to(b);
    }
    function darkenHex(hex, delta){
      // delta -1..1 (negative = darker)
      const {r,g,b} = hexToRgb(hex);
      const f = clamp(1 + delta, 0, 2);
      const rr = clamp(Math.round(r*f), 0, 255);
      const gg = clamp(Math.round(g*f), 0, 255);
      const bb = clamp(Math.round(b*f), 0, 255);
      return rgbToHex(rr,gg,bb);
    }

    function getOptionalNumber(id){
      const v = ($(id).value ?? "").trim();
      if(!v) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function getCfg(){
      const colWidths = parseColWidths($("colWidths").value);
      const cw = colWidths[0];

      const downPct = clamp(Number($("downPct").value), 1, 99);
      const keyFactor = Number($("keyFactor").value);
      const noteFactor = Number($("noteFactor").value);

      const noteCanvas = parseWxH($("noteCanvas").value, 300, 300);

      return {
        cw,
        downPct,

        keyCanvas2x: { w: 224, h: 366 }, // FIXO como você pediu

        key: {
          prefix: ($("keyPrefix").value.trim() || "mania-key"),
          pressedPrefix: ($("keyPressedPrefix").value.trim() || "mania-keyD"),
          factor: keyFactor,

          fillColor: $("keyFillColor").value,
          fillA: clamp(Number($("keyFillA").value), 0, 1),

          outlineColor: $("keyOutlineColor").value,
          outlinePx2x: clamp(Number($("keyOutlinePx").value), 0, 999),
          outlineA: clamp(Number($("keyOutlineA").value), 0, 1),

          pressedDelta: clamp(Number($("keyPressedDelta").value), -1, 1),
          pressedFillA: (()=>{ const n=getOptionalNumber("keyPressedFillA"); return n===null?null:clamp(n,0,1); })(),
          pressedOutlineA: (()=>{ const n=getOptionalNumber("keyPressedOutlineA"); return n===null?null:clamp(n,0,1); })(),
        },

        note: {
          prefix: ($("notePrefix").value.trim() || "mania-note"),
          lnPrefix: ($("noteLnPrefix").value.trim() || "mania-noteH"),
          factor: noteFactor,

          fillColor: $("noteFillColor").value,
          fillA: clamp(Number($("noteFillA").value), 0, 1),

          outlineColor: $("noteOutlineColor").value,
          outlinePx2x: clamp(Number($("noteOutlinePx").value), 0, 999),
          outlineA: clamp(Number($("noteOutlineA").value), 0, 1),

          yOffset: clamp(Number($("noteYOffset").value), -9999, 9999),
          canvas2x: noteCanvas,

          motionBlur: {
            on: $("mbOn").value === "on",
            angleDeg: ((Number($("mbAngle").value)%360)+360)%360,
            dist: clamp(Number($("mbDist").value), 0, 2000),
            blur: clamp(Number($("mbBlur").value), 0, 2000),
            alpha: clamp(Number($("mbAlpha").value), 0, 1),
            steps: clamp(Number($("mbSteps").value), 2, 300),
          }
        }
      };
    }

    // ColumnWidth is treated as @1x baseline: d@1x = cw*factor, d@2x = d@1x*2
    function diameter2xFromCW(cw, factor){
      const d1 = cw * factor;
      return Math.max(1, Math.round(d1 * 2));
    }

    function safeInnerRadius(r, outlinePx){
      const rr = Math.max(0.5, r);
      const o = Math.max(0, outlinePx);
      return Math.max(0.5, rr - o/2);
    }

    function drawCircle(ctx, cx, cy, r, opts){
      // No default fill/outline unless alpha > 0 (keeps PNG transparent by default)
      const fillA = clamp(opts.fillA ?? 0, 0, 1);
      const outlineA = clamp(opts.outlineA ?? 0, 0, 1);
      const outlinePx = Math.max(0, opts.outlinePx||0);

      const fillColor = opts.fillColor || "#888888";
      const outlineColor = opts.outlineColor || "#ffffff";

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      const rr = safeInnerRadius(r, outlinePx);

      if(fillA > 0){
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI*2);
        ctx.closePath();
        ctx.fillStyle = `rgba(${hexToRgb(fillColor).r},${hexToRgb(fillColor).g},${hexToRgb(fillColor).b},${fillA})`;
        ctx.fill();
      }

      if(outlinePx > 0 && outlineA > 0){
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI*2);
        ctx.closePath();
        const rgb = hexToRgb(outlineColor);
        ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${outlineA})`;
        ctx.lineWidth = outlinePx;
        ctx.stroke();
      }

      ctx.restore();
    }

    // Motion blur: draw many blurred stamps of the circle along a vector (behind the LN note)
    function drawMotionBlurTrail(ctx, cx, cy, r, blurCfg, circleStyle){
      if(!blurCfg.on) return;
      if(blurCfg.alpha <= 0) return;
      if(blurCfg.dist <= 0) return;
      if(circleStyle.fillA <= 0 && circleStyle.outlineA <= 0) return; // nothing to blur

      const steps = Math.max(2, Math.floor(blurCfg.steps));
      const ang = (blurCfg.angleDeg * Math.PI) / 180;
      const dx = Math.cos(ang);
      const dy = -Math.sin(ang); // canvas y+ is down; angle=90 should go UP, hence -sin

      // We'll blur the WHOLE stamp; easiest is using ctx.filter
      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.filter = blurCfg.blur > 0 ? `blur(${blurCfg.blur}px)` : "none";
      ctx.globalCompositeOperation = "source-over";

      // Stronger near circle, fading away
      for(let i=1;i<=steps;i++){
        const t = i/steps; // 0..1
        const ox = dx * blurCfg.dist * t;
        const oy = dy * blurCfg.dist * t;

        // alpha curve (quadratic falloff) * user alpha
        const a = blurCfg.alpha * (1 - t) * (1 - t);

        // draw just the FILL portion for the blur (usually what you want like your example)
        // if fillA=0, we can blur the outline instead, but default effect is fill-blur.
        const useFillA = (circleStyle.fillA > 0 ? circleStyle.fillA : circleStyle.outlineA) * a;

        drawCircle(ctx, cx + ox, cy + oy, r, {
          fillColor: circleStyle.fillColor,
          fillA: useFillA,
          outlineColor: circleStyle.outlineColor,
          outlinePx: circleStyle.outlinePx,
          outlineA: (circleStyle.fillA > 0 ? 0 : circleStyle.outlineA * a) // only if no fill
        });
      }

      ctx.restore();
    }

    function renderNoteCanvas(cfg, isLN){
      const d2x = diameter2xFromCW(cfg.cw, cfg.note.factor);
      const c = makeCanvas(cfg.note.canvas2x.w, cfg.note.canvas2x.h);
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height); // transparent background

      const cx = c.width/2;
      const cy = c.height/2 + cfg.note.yOffset;
      const r = d2x/2;

      const circleStyle = {
        fillColor: cfg.note.fillColor,
        fillA: cfg.note.fillA,
        outlineColor: cfg.note.outlineColor,
        outlinePx: cfg.note.outlinePx2x,
        outlineA: cfg.note.outlineA
      };

      // LN blur behind (no “trilha em cima”, é motion blur tipo seu exemplo)
      if(isLN){
        drawMotionBlurTrail(ctx, cx, cy, r, cfg.note.motionBlur, circleStyle);
      }

      // main note circle on top
      drawCircle(ctx, cx, cy, r, circleStyle);

      return { canvas: c, d2x };
    }

    function renderKeyCanvas(cfg, pressed){
      const d2x = diameter2xFromCW(cfg.cw, cfg.key.factor);
      const c = makeCanvas(cfg.keyCanvas2x.w, cfg.keyCanvas2x.h); // FIXO 224x366
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height); // transparent background

      const cx = c.width/2;
      const cy = c.height/2;
      const r = d2x/2;

      const baseFill = pressed ? darkenHex(cfg.key.fillColor, cfg.key.pressedDelta) : cfg.key.fillColor;

      const fillA = pressed && cfg.key.pressedFillA !== null ? cfg.key.pressedFillA : cfg.key.fillA;
      const outlineA = pressed && cfg.key.pressedOutlineA !== null ? cfg.key.pressedOutlineA : cfg.key.outlineA;

      drawCircle(ctx, cx, cy, r, {
        fillColor: baseFill,
        fillA,
        outlineColor: cfg.key.outlineColor,
        outlinePx: cfg.key.outlinePx2x,
        outlineA
      });

      return { canvas: c, d2x };
    }

    function paintPreview(previewCanvas, srcCanvas){
      const ctx = previewCanvas.getContext("2d");
      ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);

      const pw = previewCanvas.width, ph = previewCanvas.height;
      const sw = srcCanvas.width, sh = srcCanvas.height;
      const scale = Math.min(pw/sw, ph/sh);
      const dw = sw * scale;
      const dh = sh * scale;
      const dx = (pw - dw)/2;
      const dy = (ph - dh)/2;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(srcCanvas, dx, dy, dw, dh);
    }

    function addThumb(title, items){
      const out = $("out");
      const wrap = document.createElement("div");
      wrap.className = "thumb";

      const top = document.createElement("div");
      top.className = "top";
      const b = document.createElement("b");
      b.textContent = title;
      top.appendChild(b);

      const imgBox = document.createElement("div");
      imgBox.className = "img";

      items.forEach(({name, blob})=>{
        const url = URL.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = url;
        img.alt = name;
        imgBox.appendChild(img);
      });

      const btnRow = document.createElement("div");
      btnRow.className = "smallRow";
      items.forEach(({name, blob})=>{
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.style.padding = "7px 10px";
        btn.textContent = "baixar " + name;
        btn.onclick = ()=>downloadBlob(blob, name);
        btnRow.appendChild(btn);
      });

      imgBox.appendChild(btnRow);

      wrap.appendChild(top);
      wrap.appendChild(imgBox);
      out.appendChild(wrap);
    }

    let generatedFiles = [];
    let latestCfgForZip = null;

    function clearOutAndResetDefaults(){
      // Reset everything to "transparent default"
      $("noteFillA").value = "0";
      $("noteOutlinePx").value = "0";
      $("noteOutlineA").value = "0";
      $("mbAlpha").value = "0";

      $("keyFillA").value = "0";
      $("keyOutlinePx").value = "0";
      $("keyOutlineA").value = "0";
      $("keyPressedDelta").value = "0";
      $("keyPressedFillA").value = "";
      $("keyPressedOutlineA").value = "";

      $("out").innerHTML = "";
      generatedFiles = [];
      $("fileCount").textContent = "0 arquivos";
      setStatus("limpo");

      scheduleUpdate();
    }

    async function regenerateFilesAndUI(){
      const cfg = getCfg();
      latestCfgForZip = cfg;

      // --- Render source canvases ---
      const noteN = renderNoteCanvas(cfg, false).canvas;
      const noteL = renderNoteCanvas(cfg, true).canvas;
      const keyN  = renderKeyCanvas(cfg, false).canvas;
      const keyP  = renderKeyCanvas(cfg, true).canvas;

      // --- Previews ---
      paintPreview($("pvNote"), noteN);
      paintPreview($("pvLn"),   noteL);
      paintPreview($("pvKey"),  keyN);
      paintPreview($("pvKeyP"), keyP);

      $("pvInfoNote").textContent = `${noteN.width}×${noteN.height}`;
      $("pvInfoLn").textContent   = `${noteL.width}×${noteL.height}`;
      $("pvInfoKey").textContent  = `${keyN.width}×${keyN.height}`;
      $("pvInfoKeyP").textContent = `${keyP.width}×${keyP.height}`;

      // --- Build export canvases (downscale) ---
      const noteNDown = downscaleCanvas(noteN, cfg.downPct);
      const noteLDown = downscaleCanvas(noteL, cfg.downPct);
      const keyNDown  = downscaleCanvas(keyN, cfg.downPct);
      const keyPDown  = downscaleCanvas(keyP, cfg.downPct);

      // Names
      const noteN2xName = `${cfg.note.prefix}@2x.png`;
      const noteN1xName = `${cfg.note.prefix}.png`;
      const noteL2xName = `${cfg.note.lnPrefix}@2x.png`;
      const noteL1xName = `${cfg.note.lnPrefix}.png`;

      const keyN2xName  = `${cfg.key.prefix}@2x.png`;
      const keyN1xName  = `${cfg.key.prefix}.png`;
      const keyP2xName  = `${cfg.key.pressedPrefix}@2x.png`;
      const keyP1xName  = `${cfg.key.pressedPrefix}.png`;

      // Blobs
      const [
        noteN2xBlob, noteN1xBlob,
        noteL2xBlob, noteL1xBlob,
        keyN2xBlob,  keyN1xBlob,
        keyP2xBlob,  keyP1xBlob
      ] = await Promise.all([
        canvasToBlob(noteN), canvasToBlob(noteNDown),
        canvasToBlob(noteL), canvasToBlob(noteLDown),
        canvasToBlob(keyN),  canvasToBlob(keyNDown),
        canvasToBlob(keyP),  canvasToBlob(keyPDown)
      ]);

      generatedFiles = [
        {name: noteN2xName, blob: noteN2xBlob},
        {name: noteN1xName, blob: noteN1xBlob},
        {name: noteL2xName, blob: noteL2xBlob},
        {name: noteL1xName, blob: noteL1xBlob},
        {name: keyN2xName,  blob: keyN2xBlob},
        {name: keyN1xName,  blob: keyN1xBlob},
        {name: keyP2xName,  blob: keyP2xBlob},
        {name: keyP1xName,  blob: keyP1xBlob},
      ];

      // Output UI
      $("out").innerHTML = "";
      addThumb("notes", [
        {name:noteN2xName, blob:noteN2xBlob},
        {name:noteN1xName, blob:noteN1xBlob},
        {name:noteL2xName, blob:noteL2xBlob},
        {name:noteL1xName, blob:noteL1xBlob},
      ]);
      addThumb("keys", [
        {name:keyN2xName, blob:keyN2xBlob},
        {name:keyN1xName, blob:keyN1xBlob},
        {name:keyP2xName, blob:keyP2xBlob},
        {name:keyP1xName, blob:keyP1xBlob},
      ]);

      $("fileCount").textContent = `${generatedFiles.length} arquivos`;
      setStatus("pronto ✅");
    }

    async function downloadZip(){
      if(!generatedFiles.length){
        setStatus("nada pra zipar");
        return;
      }
      if(typeof JSZip === "undefined"){
        setStatus("JSZip não carregou");
        alert("JSZip não carregou. Você ainda pode baixar cada PNG individualmente.");
        return;
      }
      setStatus("zipando…");
      const zip = new JSZip();
      const folder = zip.folder("osu-mania");
      for(const f of generatedFiles){
        folder.file(f.name, f.blob);
      }
      const blob = await zip.generateAsync({type:"blob"});
      downloadBlob(blob, "osu-mania-images.zip");
      setStatus("pronto ✅");
    }

    // Debounce updates so typing doesn't spam blob creation
    let tmr = null;
    let busy = false;
    let queued = false;

    function scheduleUpdate(){
      if(tmr) clearTimeout(tmr);
      tmr = setTimeout(async ()=>{
        if(busy){
          queued = true;
          return;
        }
        busy = true;
        try{
          await regenerateFilesAndUI();
        }catch(err){
          console.error(err);
          setStatus("erro");
        }finally{
          busy = false;
          if(queued){
            queued = false;
            scheduleUpdate();
          }
        }
      }, 180);
    }

    function bindRealtime(){
      const ids = [
        "colWidths","keyFactor","noteFactor","downPct","noteCanvas",

        "notePrefix","noteLnPrefix",
        "noteFillColor","noteFillA",
        "noteOutlineColor","noteOutlinePx","noteOutlineA",
        "noteYOffset",

        "mbOn","mbAngle","mbDist","mbBlur","mbAlpha","mbSteps",

        "keyPrefix","keyPressedPrefix",
        "keyFillColor","keyFillA",
        "keyOutlineColor","keyOutlinePx","keyOutlineA",
        "keyPressedDelta","keyPressedFillA","keyPressedOutlineA"
      ];

      ids.forEach(id=>{
        const el = $(id);
        el.addEventListener("input", ()=>{ setStatus("…"); scheduleUpdate(); });
        el.addEventListener("change", ()=>{ setStatus("…"); scheduleUpdate(); });
      });
    }

    function bind(){
      $("zipBtn").addEventListener("click", downloadZip);
      $("clearBtn").addEventListener("click", clearOutAndResetDefaults);

      bindRealtime();

      // Start clean/transparent by default
      $("out").innerHTML = "";
      generatedFiles = [];
      $("fileCount").textContent = "0 arquivos";
      setStatus("pronto");

      // First auto-gen (will still be transparent until you raise alphas)
      scheduleUpdate();
    }

    bind();
  </script>
</body>
</html>
